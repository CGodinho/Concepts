z <- lapply(map_area_region$Area.Code, getRegion)
z
z <- lapply(map_area_region, 1, getRegion)
z <- apply(map_area_region, 1, getRegion)
apply(map_area_region, 1, getRegion)
apply(map_area_region, 1, getRegion)
z[] <- apply(map_area_region, 1, getRegion)
warnings()
z
as.vector(z)
# Returns a region, given a value and
getRegion <- function(value), output {
map_area_region[map_area_region$Area.Code == value,]$Region
}
# Returns a region, given a value and
getRegion <- function(value, output) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
z[] <- apply(map_area_region, 1, getRegion)
apply(map_area_region, 1, getRegion)
apply(postcode_area$name, 1, getRegion)
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
postcode_area$name
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
apply(postcode_area$name, 1, getRegion)
apply(postcode_area$name, getRegion)
apply(postcode_area$name, 2, getRegion)
apply(postcode_area, 2, getRegion)
apply(postcode_area, 1, getRegion)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value$name,]$Region
}
apply(postcode_area, 1, getRegion)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
getRegion("L")
sapply(postcode_area, 1, getRegion)
lapply(postcode_area, 1, getRegion)
lapply(postcode_area$name, 1, getRegion)
lapply(postcode_area$name, getRegion)
z <- lapply(postcode_area$name, getRegion)
z
class(z)
class(z)
as.data.frame(z)
as.data.frame(do.call(rbind, z))
cores <- as.data.frame(do.call(rbind, z))
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
pal <- colorBin("YlOrRd", domain = cores, bins = bins)
m <- leaflet(area_bins) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(cores))
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(cores))
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name))
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(cores))
cores <- as.numreic(as.data.frame(do.call(rbind, z)))
cores <- as.numeric(as.data.frame(do.call(rbind, z)))
cores <- as.data.frame(do.call(rbind, z))
class(cores)
class(cores$V1)
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
pal <- colorBin("YlOrRd", domain = cores$v1, bins = bins)
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(cores$v1))
m
cores$v1
cores <- as.data.frame(do.call(rbind, z))
cores
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
pal <- colorBin("YlOrRd", domain = cores, bins = bins)
vec_cores <- as.vecotr(cores)
vec_cores <- as.vector(cores)
vec_cores
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,13, 14)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
vec_cores <- as.vector(cores)
vec_cores
vec_cores
cores$V1
cores$V1
cores$V1
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores$V1
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,13, 14)
pal <- colorBin("YlOrRd", domain = vec_cores$v1, bins = bins)
cores$V1
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(cores$v1))
m
class(cores$V1)
cores$V1 <- as.numeric(cores$V1)
cores$V1 <- as.numeric(cores$V1)
class(cores$v1)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores$V1 <- as.numeric(cores$V1)
class(cores$v1)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores
mycores <- as.numeric(cores$V1)
class(mycores)
mycores
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,13, 14)
pal <- colorBin("YlOrRd", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
area_bins < -unique(map_area_region$Region)
pal <- colorBin("info2", domain = states$density, bins = area_bins)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
mycores <- as.numeric(cores$V1)
class(mycores)
unique(mycores)
sort(unique(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,13, 14)
pal <- colorBin("YlOrRd", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
pal <- colorBin("info2", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
pal <- colorBin("info2", domain = mycores, bins = bins)
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
table(map_area_region$Region)
m %>% addProviderTiles("CartoDB.Positron")
map_area_region <- read.csv("C:/Temp/postcode_map_areas_regions.txt")
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
getRegion("L")
class(postcode_area)
names(postcode_area)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores
mycores <- as.numeric(cores$V1)
class(mycores)
sort(unique(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m %>% addProviderTiles("CartoDB.Positron")
m %>% addProviderTiles("CartoDB.Positron")
m %>% addProviderTiles("CartoDB.Positron")
library(rgdal)
library(leaflet)
library(readr)
postcodes = readOGR("c:/Temp/postcode_polygons.gpkg", layer = "postcode_district")
postcodes
proj4string(postcodes)
postcodes = spTransform(postcodes, CRS("+proj=longlat +datum=WGS84"))
proj4string(postcodes)
postcodes
postcodes_districts = subset(postcodes, grepl(".*", postcodes$pc_district))
postcodes_districts
leaflet(postcodes_districts, width = "100%") %>%
setView(lng = -3.64, lat = 58, zoom = 7) %>%
addTiles() %>%
addPolygons()
postcode_areas = subset(postcodes, grepl(".*", postcodes$pc_areas))
postcode_areas
leaflet(postcode_areas, width = "100%") %>%
setView(lng = -3.64, lat = 58, zoom = 7) %>%
addTiles() %>%
addPolygons()
example <- sample(1:10, 124, replace = T)
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
pal <- colorBin("YlOrRd", domain = example, bins = bins)
pal
library(leaflet)
library(rgdal)
post.areas <- readOGR(dsn="Distribution", layer="Areas")
post.areas
pal
library(rgdal)
post.areas <- readOGR(dsn="Distribution", layer="Areas")
post.areas
library(leaflet)
dim(post.areas)
class(post.areas)
m <- leaflet(post.areas) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(example))
m %>% addProviderTiles("CartoDB.Positron")
class(post.areas$name)
post.areas <- post.areas$name
post.areas
map_area_region <- read.csv("C:/Temp/postcode_map_areas_regions.txt")
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
getRegion("L")
class(postcode_area)
names(postcode_area)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores
mycores <- as.numeric(cores$V1)
class(mycores)
sort(unique(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
m %>% addProviderTiles("CartoDB.Positron")
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
table(map_area_region$Region)
library(rgdal)
library(leaflet)
library(readr)
postcodes = readOGR("c:/Temp/postcode_polygons.gpkg", layer = "postcode_district")
postcodes
proj4string(postcodes)
postcodes = spTransform(postcodes, CRS("+proj=longlat +datum=WGS84"))
proj4string(postcodes)
postcodes
postcodes_districts = subset(postcodes, grepl(".*", postcodes$pc_district))
postcodes_districts
leaflet(postcodes_districts, width = "100%") %>%
setView(lng = -3.64, lat = 58, zoom = 7) %>%
addTiles() %>%
addPolygons()
postcode_areas = subset(postcodes, grepl(".*", postcodes$pc_areas))
postcode_areas
leaflet(postcode_areas, width = "100%") %>%
setView(lng = -3.64, lat = 58, zoom = 7) %>%
addTiles() %>%
addPolygons()
example <- sample(1:10, 124, replace = T)
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
pal <- colorBin("YlOrRd", domain = example, bins = bins)
pal
library(leaflet)
library(rgdal)
post.areas <- readOGR(dsn="Distribution", layer="Areas")
post.areas
class(post.areas)
dim(post.areas)
m <- leaflet(post.areas) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "red", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(example))
m
m %>% addProviderTiles("CartoDB.Positron")
class(post.areas$name)
post.areas <- post.areas$name
post.areas
map_area_region <- read.csv("C:/Temp/postcode_map_areas_regions.txt")
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
getRegion("L")
class(postcode_area)
names(postcode_area)
cores <- as.data.frame(do.call(rbind, z))
z <- lapply(postcode_area$name, getRegion)
cores
mycores <- as.numeric(cores$V1)
class(mycores)
sort(unique(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
m %>% addProviderTiles("CartoDB.Positron")
table(map_area_region$Region)
z <- lapply(postcode_area$name, getRegion)
cores <- as.data.frame(do.call(rbind, z))
cores
mycores <- as.numeric(cores$V1)
class(mycores)
sort(unique(mycores))
bins <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, Inf)
pal <- colorBin("Spectral", domain = mycores, bins = bins)
pal
m <- leaflet(postcode_area) %>%
setView(lng = -5, lat = 55, zoom = 5) %>%
addPolygons(weight = 1, opacity = 0.7, color = "black", fillOpacity = 0.7, smoothFactor = 0.5, popup = ~(name), fillColor = ~pal(mycores))
m
postcode_area
z <- lapply(postcode_area$name, getRegion)
z
z
map_area_region <- read.csv("C:/Temp/postcode_map_areas_regions.txt")
map_area_region <- read.csv("C:/Temp/postcode_map_areas_regions.txt")
map_area_region
map_area_region[map_area_region$Region == "Other"]
map_area_region[map_area_region$Region == "Other",]
map_area_region[map_area_region$Region != "Other",]
map_area_region <- map_area_region[map_area_region$Region != "Other",]
map_area_region[map_area_region$Region == "Other",]
map_area_region
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
getRegion("L")
class(postcode_area)
names(postcode_area)
postcode_area
m
map_area_region$Region <- as.factor(map_area_region$Region)
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
map_area_region$Region <- as.factor(as.character(map_area_region$Region))
postcode_area <- readOGR(dsn = "Distribution", layer = "Areas")
table(map_area_region$Region)
# Returns a region, given a value and
getRegion <- function(value) {
map_area_region[map_area_region$Area.Code == value,]$Region
}
getRegion("L")
class(postcode_area)
names(postcode_area)
postcode_area
m
cores
sort(unique(mycores))
class(postcode_area)
names(postcode_area)
postcode_area
table(map_area_region$Region)
##############################################################################
# Clean environment
##############################################################################
rm(list=ls())
set.seed(2510)
install.packages("e1071")
library(readr)
library(caret)
library(party)
library(ggplot2)
library(corrplot)
library(doParallel)
library(randomForest)
library(AppliedPredictiveModeling)
###############################################################################
# Parallel processing
###############################################################################
cl <- makeCluster(detectCores(), type='PSOCK')
registerDoParallel(cl)
###############################################################################
# Load data
###############################################################################
setwd("c:/git/Concepts/Wine_Quality/")
trainingFile <- read.csv("winequality-white.csv", sep = ";", na.strings = c("NA", ""))
View(trainingFile)
###############################################################################
# Exploratory data analysis
###############################################################################
dim(trainingFile)
str(trainingFile)
summary(trainingFile)
range(trainingFile$quality)
any(is.na(trainingFile))
table(trainingFile$quality)
head(trainingFile[,1:4])
hist(trainingFile$quality)
hist(trainingFile$pH)
par(mfrow=c(2,2))
plot(trainingFile$quality,trainingFile$alcohol, main="Quality cs Alcohol")
plot(trainingFile$quality,trainingFile$pH, main="Quality vs PH")
plot(trainingFile$citric.acid,trainingFile$residual.sugar, main="Citric Acid vs Residual Sugar")
plot(trainingFile$chlorides,trainingFile$density, main="Chlorides vs Density")
ggplot(trainingFile, aes(x = quality)) +
geom_histogram(aes(fill = ..count..), binwidth = 0.5) +
ggtitle("Histogram of Quality") +
scale_fill_gradient("Count", low = "blue", high = "red")
ggplot(trainingFile, aes(x=quality, y=pH, color=quality)) +
geom_violin(trim=FALSE, fill ="skyblue3") +
ggtitle("Violinplot quality vs PH") +
stat_summary(fun.y=mean, geom="point", shape=1, size=1, color="chocolate4")
###############################################################################
# Data tpye convertions
###############################################################################
trainingFile$quality <- make.names(trainingFile$quality)
trainingFile$quality <- as.factor(trainingFile$quality)
str(trainingFile$quality)
###############################################################################
# Variance
###############################################################################
nzv <- nearZeroVar(trainingFile,  saveMetrics = TRUE, allowParallel = TRUE)
nzv
###############################################################################
# Correlation
# NOTE: http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software
###############################################################################
correlated <- cor(trainingFile[,-12])
correlated
corrplot(correlated, type = "upper", order = "hclust", tl.col = "black", tl.srt = 45)
highCorr <- sum(abs(correlated[upper.tri(correlated)]) > 0.9)
highCorr
col<- colorRampPalette(c("blue", "white", "red"))(20)
heatmap(x = correlated, col = col, symm = TRUE)
###############################################################################
# Create datasets fro validation and training
###############################################################################
dataPartititon <- createDataPartition(trainingFile$quality, p = 0.75, list = FALSE)
trainingSet    <- trainingFile[dataPartititon, ]
validationSet  <- trainingFile[-dataPartititon, ]
# remove column density and quality
trainingSet <- trainingSet[, -c(1:2)]
trainingSet
###############################################################################
# Caret with random forest
###############################################################################
fitControl <- trainControl(method = "repeatedcv", repeats = 5, classProbs = TRUE)
grid <- expand.grid(.interaction.depth = seq(1, 10, by = 1),
.n.trees = seq(100, 2000, by = 50),
.shrinkage = c(0.01, 0.1))
head(trainingSet)
# Data is center and scale and model runs .....
Sys.time()
model_RandomForest <- train(quality ~ ., data = trainingSet, method = "rf", preProc = c("center", "scale"), verbose = FALSE, trControl = fitControl)
Sys.time()
model_RandomForest
plot(model_RandomForest)
varImpPlot(model_RandomForest$finalModel)
dim(validationSet)
predict_RandomForest <- predict(model_RandomForest, validationSet)
confusionMatrix(predict_RandomForest, validationSet$quality)
plot(model_RandomForest$finalModel)
tree <- getTree(model_RandomForest$finalModel,k = 1)
plot(tree)
model_RandomForest
plot(model_RandomForest)
grid <- expand.grid(.interaction.depth = seq(1, 10, by = 1),
.n.trees = seq(100, 2000, by = 50),
.shrinkage = c(0.01, 0.1))
head(trainingSet)
# Data is center and scale and model runs .....
Sys.time()
Sys.time()
model_RandomForest
plot(model_RandomForest)
varImpPlot(model_RandomForest$finalModel)
dim(validationSet)
predict_RandomForest <- predict(model_RandomForest, validationSet)
confusionMatrix(predict_RandomForest, validationSet$quality)
